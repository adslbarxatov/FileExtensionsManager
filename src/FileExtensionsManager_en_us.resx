<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbortButton" xml:space="preserve">
    <value>&amp;Cancel</value>
  </data>
  <data name="AppliedText" xml:space="preserve">
    <value>Applied: </value>
  </data>
  <data name="ApplyAllEntries" xml:space="preserve">
    <value>Apply all entries?</value>
  </data>
  <data name="ApplyAllEntries2" xml:space="preserve">
    <value>Has your decision changed?</value>
  </data>
  <data name="ApplyButton" xml:space="preserve">
    <value>&amp;Apply</value>
  </data>
  <data name="ApplyEntry" xml:space="preserve">
    <value>Apply selected entries?</value>
  </data>
  <data name="BasesNotFound" xml:space="preserve">
    <value>No bases of registry entries found</value>
  </data>
  <data name="ButtonsPanel_AddRecord" xml:space="preserve">
    <value>&amp;Add</value>
  </data>
  <data name="ButtonsPanel_Apply" xml:space="preserve">
    <value>A&amp;pply selected</value>
  </data>
  <data name="ButtonsPanel_ApplyAll" xml:space="preserve">
    <value>Appl&amp;y all</value>
  </data>
  <data name="ButtonsPanel_DeleteRecord" xml:space="preserve">
    <value>&amp;Delete selected</value>
  </data>
  <data name="ButtonsPanel_EditRecord" xml:space="preserve">
    <value>&amp;Edit</value>
  </data>
  <data name="ButtonsPanel_Exit" xml:space="preserve">
    <value>E&amp;xit</value>
  </data>
  <data name="ButtonsPanel_FindIcon" xml:space="preserve">
    <value>Find &amp;icon</value>
  </data>
  <data name="ButtonsPanel_LoadRegFile" xml:space="preserve">
    <value>&amp;Load from file</value>
  </data>
  <data name="ButtonsPanel_RegExtension" xml:space="preserve">
    <value>&amp;Register extension</value>
  </data>
  <data name="ButtonsPanel_SaveRegFile" xml:space="preserve">
    <value>&amp;Save to file</value>
  </data>
  <data name="EntriesAdded" xml:space="preserve">
    <value>Added: </value>
  </data>
  <data name="EntriesApplied" xml:space="preserve">
    <value>Applied {0:D} from {1:D}</value>
  </data>
  <data name="EntryIsIncorrect" xml:space="preserve">
    <value>Entry is incorrect. Make sure that path to registry key is correct, parameter name doesn’t contain the “\” character, and value matches the specified type, then try again</value>
  </data>
  <data name="EntryIsUnavailable" xml:space="preserve">
    <value>Entry cannot be applied: needed registry key is not available</value>
  </data>
  <data name="EntryNotApplied" xml:space="preserve">
    <value>Cannot apply entry</value>
  </data>
  <data name="ER_OFDialogFilter" xml:space="preserve">
    <value>Executables|*.exe</value>
  </data>
  <data name="ER_OFDialogText" xml:space="preserve">
    <value>Select an application to open this file type</value>
  </data>
  <data name="ER_Title" xml:space="preserve">
    <value> – extension registration</value>
  </data>
  <data name="ExtensionRegFailed" xml:space="preserve">
    <value>Failed to create one or more entries to register the extension. Make sure that application has rights to work with the registry, then try again</value>
  </data>
  <data name="ExtensionRegistrator_AttentionLabel" xml:space="preserve">
    <value>Attention! Some applications may not support “Open with” command or support it in a non-standard way. In these cases, this function may not work correctly</value>
  </data>
  <data name="ExtensionRegistrator_ExecutableLabel" xml:space="preserve">
    <value>Executable for opening:</value>
  </data>
  <data name="ExtensionRegistrator_ExtensionLabel" xml:space="preserve">
    <value>File extension (without point):</value>
  </data>
  <data name="ExtensionRegistrator_IconLabel" xml:space="preserve">
    <value>File icon:</value>
  </data>
  <data name="ExtensionRegistrator_TypeLabel" xml:space="preserve">
    <value>File type name:</value>
  </data>
  <data name="FEMF_OFDialogFilter" xml:space="preserve">
    <value>Windows registry file (*.reg)|*.reg</value>
  </data>
  <data name="FEMF_OFDialogTitle" xml:space="preserve">
    <value>Specify registry file for loading</value>
  </data>
  <data name="FileExtensionsManagerForm_BaseLabel" xml:space="preserve">
    <value>Current &amp;base:</value>
  </data>
  <data name="HelpText" xml:space="preserve">
    <value>Application allows you to store and apply custom settings for file extensions registered in the operating system. List of records displays registry mappings stored in currently selected base of records.

Green indicates entries that already exist in Windows registry, blue indicates entries that partially correspond to user settings, and red indicates missing entries. If record is marked as deleted, then entries that are absent in registry are marked in green, otherwise they are marked in red. Presence of gray entries may indicate a lack of access to Windows registry.

You can change the record by double-clicking on corresponding line, and add it using corresponding button. In both cases, information is edited in a special window, and their correctness is controlled by utility. You can also add entries from Windows registry file.

You can apply entries one at a time or all at once (all that not applied). The “Exit” button saves all changes in all bases. If changes need to be undone, the application must be closed with a cross in the upper right corner of window.

For now, utility only works with entries in registry branch HKEY_CLASSES_ROOT and only with parameter types REG_SZ, REG_DWORD, and REG_QWORD</value>
  </data>
  <data name="IconsNotFound" xml:space="preserve">
    <value>File “{0:S}” contains no icons</value>
  </data>
  <data name="IE_OFDialogFilter" xml:space="preserve">
    <value>Executables, libraries, assemblies, icons|*.ico;*.exe;*.dll;*.sfx;*.cpl|All files|*.*</value>
  </data>
  <data name="IE_OFDialogTitle" xml:space="preserve">
    <value>Select file to view icons</value>
  </data>
  <data name="IE_PageLabel" xml:space="preserve">
    <value>Page:</value>
  </data>
  <data name="IE_SelectButtonText" xml:space="preserve">
    <value>&amp;Select #</value>
  </data>
  <data name="IE_Title" xml:space="preserve">
    <value> – icons view</value>
  </data>
  <data name="IE_TotalLabelText" xml:space="preserve">
    <value>Total: </value>
  </data>
  <data name="NewBaseAdded" xml:space="preserve">
    <value>Application will create an empty sample file. Give it a convenient name, then run the utility again</value>
  </data>
  <data name="NoAccessText" xml:space="preserve">
    <value>Unavailable: </value>
  </data>
  <data name="NotAppliedText" xml:space="preserve">
    <value>Not applied: </value>
  </data>
  <data name="OpenButton" xml:space="preserve">
    <value>&amp;Open</value>
  </data>
  <data name="PartiallyAppliedText" xml:space="preserve">
    <value>Partially applied: </value>
  </data>
  <data name="rebfile" xml:space="preserve">
    <value>Registry entries base file</value>
  </data>
  <data name="REE_Title" xml:space="preserve">
    <value> – entry creation</value>
  </data>
  <data name="RegistryEntryEditor_EntryPath" xml:space="preserve">
    <value>Entry path:</value>
  </data>
  <data name="RegistryEntryEditor_NameMustBeDeleted" xml:space="preserve">
    <value>Parameter to be deleted</value>
  </data>
  <data name="RegistryEntryEditor_ParameterName" xml:space="preserve">
    <value>Parameter name:</value>
  </data>
  <data name="RegistryEntryEditor_ParameterType" xml:space="preserve">
    <value>Parameter type:</value>
  </data>
  <data name="RegistryEntryEditor_ParameterValue" xml:space="preserve">
    <value>Parameter value:</value>
  </data>
  <data name="RegistryEntryEditor_PathMustBeDeleted" xml:space="preserve">
    <value>Path to be deleted</value>
  </data>
  <data name="RegistryValue_Int32" xml:space="preserve">
    <value> (integer, 4 bytes)</value>
  </data>
  <data name="RegistryValue_Int64" xml:space="preserve">
    <value> (integer, 8 bytes)</value>
  </data>
  <data name="RegistryValue_String" xml:space="preserve">
    <value> (string)</value>
  </data>
  <data name="RemoveEntry" xml:space="preserve">
    <value>Remove selected entries?</value>
  </data>
  <data name="SomeFieldsAreEmpty" xml:space="preserve">
    <value>One of required fields is empty</value>
  </data>
  <data name="UnsupportedCharacter" xml:space="preserve">
    <value>File extension field contains invalid character [{0: S}]</value>
  </data>
</root>